Python 的函数具有非常灵活多样的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。从简到繁的参数形态如下：

位置参数 (positional argument)
默认参数 (default argument)
可变参数 (variable argument)
关键字参数 (keyword argument)
命名关键字参数 (name keyword argument)
参数组合

默认参数一定要放在位置参数 后面，不然程序会报错。
Python 允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。

「可变参数」和「关键字参数」的同异总结如下：

可变参数允许传入零个到任意个参数，它们在函数调用时自动组装为一个元组 (tuple)。
关键字参数允许传入零个到任意个参数，它们在函数内部自动组装为一个字典 (dict)。

 命名关键字参数

def functionname(arg1, arg2=v, args, *, nkw, *kw):
       "函数_文档字符串"
       function_suite
       return [expression]

*, nkw - 命名关键字参数，用户想要输入的关键字参数，定义方式是在nkw 前面加个分隔符 *。
如果要限制关键字参数的名字，就可以用「命名关键字参数」
使用命名关键字参数时，要特别注意不能缺少参数名。

在 Python 中定义函数，可以用位置参数、默认参数、可变参数、命名关键字参数和关键字参数，这 5 种参数中的 4 个都可以一起使用，但是注意，参数定义的顺序必须是：

位置参数、默认参数、可变参数和关键字参数。
位置参数、默认参数、命名关键字参数和关键字参数。
要注意定义可变参数和关键字参数的语法：

*args 是可变参数，args 接收的是一个 tuple
**kw 是关键字参数，kw 接收的是一个 dict
命名关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。定义命名关键字参数不要忘了写分隔符 *，否则定义的是位置参数。

警告：虽然可以组合多达 5 种参数，但不要同时使用太多的组合，否则函数很难懂。


闭包

是函数式编程的一个重要的语法结构，是一种特殊的内嵌函数。
如果在一个内部函数里对外层非全局作用域的变量进行引用，那么内部函数就被认为是闭包。
通过闭包可以访问外层非全局作用域的变量，这个作用域称为 闭包作用域。

闭包的返回值通常是函数
如果要修改闭包作用域中的变量则需要 nonlocal 关键字

在 Python 里有两类函数：

第一类：用 def 关键词定义的正规函数
第二类：用 lambda 关键词定义的匿名函数
Python 使用 lambda 关键词来创建匿名函数，而非def关键词，它没有函数名，其语法结构如下：

lambda argument_list: expression

lambda - 定义匿名函数的关键词。
argument_list - 函数参数，它们可以是位置参数、默认参数、关键字参数，和正规函数里的参数类型一样。
:- 冒号，在函数参数和表达式中间要加个冒号。
expression - 只是一个表达式，输入函数参数，输出一些值。
注意：

expression 中没有 return 语句，因为 lambda 不需要它来返回，表达式本身结果就是返回值。
匿名函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。

函数式编程 是指代码中每一块都是不可变的，都由纯函数的形式组成。这里的纯函数，是指函数本身相互独立、互不影响，对于相同的输入，总会有相同的输出，没有任何副作用。
匿名函数 常常应用于函数式编程的高阶函数 (high-order function)中，主要有两种形式：

参数是函数 (filter, map)
返回值是函数 (closure)
如，在 filter和map函数中的应用：

filter(function, iterable) 过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换。
map(function, *iterables) 根据提供的函数对指定序列做映射。

对象 = 属性 + 方法
对象是类的实例。换句话说，类主要定义对象的结构，然后我们以类为模板创建对象。类不但包含方法定义，而且还包含所有实例共享的数据。

封装：信息隐蔽技术
我们可以使用关键字 class 定义 Python 类，关键字后面紧跟类的名称、冒号和类的实现。

继承：子类自动共享父类之间数据和方法的机制

多态：不同对象对同一方法响应不同的行动

Python 的 self 相当于 C++ 的 this 指针。
类的方法与普通的函数只有一个特别的区别 —— 它们必须有一个额外的第一个参数名称（对应于该实例，即该对象本身），按照惯例它的名称是 self。在调用方法时，我们无需明确提供与参数 self 相对应的参数。

据说，Python 的对象天生拥有一些神奇的方法，它们是面向对象的 Python 的一切...

它们是可以给你的类增加魔力的特殊方法...

如果你的对象实现了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，而这一切都是自动发生的...

类有一个名为__init__(self[, param1, param2...])的魔法方法，该方法在类实例化时会自动调用。

在 Python 中定义私有变量只需要在变量名或函数名前加上“__”两个下划线，那么这个函数或变量就会为私有的了。

Python 同样支持类的继承，派生类的定义如下所示：

class DerivedClassName(BaseClassName):
       statement-1
              .
              .
              .
       statement-N

BaseClassName（基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用：

class DerivedClassName(modname.BaseClassName):
       statement-1
              .
              .
              .
       statement-N

如果子类中定义与父类同名的方法或属性，则会自动覆盖父类对应的方法或属性。

调用未绑定的父类方法Fish.__init__(self)  （Fish为父类名 ），或者使用super函数super().__init__()

Python 虽然支持多继承的形式，但我们一般不使用多继承，因为容易引起混乱。

class DerivedClassName(Base1, Base2, Base3):
       statement-1
              .
              .
              .
       statement-N

需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，Python 从左至右搜索，即方法在子类中未找到时，从左到右查找父类中是否包含方法。
注意：属性与方法名相同，属性会覆盖方法。

Python 严格要求方法需要有实例才能被调用，这种限制其实就是 Python 所谓的绑定概念。

Python 对象的数据属性通常存储在名为.__ dict__的字典中，我们可以直接访问__dict__，或利用 Python 的内置函数vars()获取.__ dict__。

issubclass(class, classinfo) 方法用于判断参数 class 是否是类型参数 classinfo 的子类。
一个类被认为是其自身的子类。
classinfo可以是类对象的元组，只要class是其中任何一个候选类的子类，则返回True。

isinstance(object, classinfo) 方法用于判断一个对象是否是一个已知的类型，类似type()。
type()不会认为子类是一种父类类型，不考虑继承关系。
isinstance()会认为子类是一种父类类型，考虑继承关系。
如果第一个参数不是对象，则永远返回False。
如果第二个参数不是类或者由类对象组成的元组，会抛出一个TypeError异常。

hasattr(object, name)用于判断对象是否包含对应的属性。

getattr(object, name[, default])用于返回一个对象属性值。

setattr(object, name, value)对应函数 getattr()，用于设置属性值，该属性不一定是存在的。

delattr(object, name)用于删除属性。


class property([fget[, fset[, fdel[, doc]]]])用于在新式类中返回属性值。
fget -- 获取属性值的函数
fset -- 设置属性值的函数
fdel -- 删除属性值函数
doc -- 属性描述信息

class C(object):
    def __init__(self):
        self.__x = None

    def getx(self):
        return self.__x

    def setx(self, value):
        self.__x = value

    def delx(self):
        del self.__x

    x = property(getx, setx, delx, "I'm the 'x' property.")


cc = C()
cc.x = 2
print(cc.x)  # 2

del cc.x
print(cc.x)
# AttributeError: 'C' object has no attribute '_C__x'

魔法方法总是被双下划线包围，例如__init__。

魔法方法是面向对象的 Python 的一切，如果你不知道魔法方法，说明你还没能意识到面向对象的 Python 的强大。

魔法方法的“魔力”体现在它们总能够在适当的时候被自动调用。

魔法方法的第一个参数应为cls（类方法） 或者self（实例方法）。

cls：代表一个类的名称
self：代表一个实例对象的名称
基本的魔法方法
__init__(self[, ...]) 构造器，当一个实例被创建的时候调用的初始化方法

__new__(cls[, ...]) 在一个对象实例化的时候所调用的第一个方法，在调用__init__初始化前，先调用__new__。
__new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由 Python 解释器自动提供，后面的参数直接传递给__init__。
__new__对当前类进行了实例化，并将实例返回，传给__init__的self。但是，执行了__new__，并不一定会进入__init__，只有__new__返回了"当前类cls的实例"，当前类的__init__才会进入。

若__new__没有正确返回当前类cls的实例，那__init__是不会被调用的，即使返回的是父类的实例也不行，将没有__init__被调用。

__new__方法主要是当你继承一些不可变的 class 时（比如int, str, tuple）， 提供给你一个自定义这些类的实例化过程的途径。

__del__(self) 析构器，当一个对象将要被系统回收之时调用的方法。
Python 采用自动引用计数（ARC）方式来回收对象所占用的空间，当程序中有一个变量引用该 Python 对象时，Python 会自动保证该对象引用计数为 1；当程序中有两个变量引用该 Python 对象时，Python 会自动保证该对象引用计数为 2，依此类推，如果一个对象的引用计数变成了 0，则说明程序中不再有变量引用该对象，表明程序不再需要该对象，因此 Python 就会回收该对象。

大部分时候，Python 的 ARC 都能准确、高效地回收系统中的每个对象。但如果系统中出现循环引用的情况，比如对象 a 持有一个实例变量引用对象 b，而对象 b 又持有一个实例变量引用对象 a，此时两个对象的引用计数都是 1，而实际上程序已经不再有变量引用它们，系统应该回收它们，此时 Python 的垃圾回收器就可能没那么快，要等专门的循环垃圾回收器（Cyclic Garbage Collector）来检测并回收这种引用循环。

__str__(self):

当你打印一个对象的时候，触发__str__
当你使用%s格式化的时候，触发__str__
str强转数据类型的时候，触发__str__
__repr__(self)：

repr是str的备胎
有__str__的时候执行__str__,没有实现__str__的时候，执行__repr__
repr(obj)内置函数对应的结果是__repr__的返回值
当你使用%r格式化的时候 触发__repr__

__str__(self) 的返回结果可读性强。也就是说，__str__ 的意义是得到便于人们阅读的信息，就像下面的 '2019-10-11' 一样。

__repr__(self) 的返回结果应更准确。怎么说，__repr__ 存在的目的在于调试，便于开发者使用。

算术运算符
类型工厂函数，指的是“不通过类而是通过函数来创建对象”。

属性访问¶
__getattr__(self, name): 定义当用户试图获取一个不存在的属性时的行为。
__getattribute__(self, name)：定义当该类的属性被访问时的行为（先调用该方法，查看是否存在该属性，若不存在，接着去调用__getattr__）。
__setattr__(self, name, value)：定义当一个属性被设置时的行为。
__delattr__(self, name)：定义当一个属性被删除时的行为。

描述符¶
描述符就是将某种特殊类型的类的实例指派给另一个类的属性。

__get__(self, instance, owner)用于访问属性，它返回属性的值。
__set__(self, instance, value)将在属性分配操作中调用，不返回任何内容。
__del__(self, instance)控制删除操作，不返回任何内容。

定制序列¶
协议（Protocols）与其它编程语言中的接口很相似，它规定你哪些方法必须要定义。然而，在 Python 中的协议就显得不那么正式。事实上，在 Python 中，协议更像是一种指南。

容器类型的协议

如果说你希望定制的容器是不可变的话，你只需要定义__len__()和__getitem__()方法。
如果你希望定制的容器是可变的话，除了__len__()和__getitem__()方法，你还需要定义__setitem__()和__delitem__()两个方法。


把一个类作为一个迭代器使用需要在类中实现两个魔法方法 __iter__() 与 __next__() 。

__iter__(self)定义当迭代容器中的元素的行为，返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。
__next__() 返回下一个迭代器对象。
StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。
